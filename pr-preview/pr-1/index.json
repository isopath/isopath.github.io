[{"content":"Repository: https://github.com/isopath/matrix.go\n//go:embed directive allows programs to include arbitrary files in the go binary at build time.\n//go:embed assets/*.txt var assetsFS embed.FS We use this to include all the text files from the assets/ directory (used for the text for rain). All values are stored in the variable assetsFS of type embed.FS, a read-only collection of files (allowing for use with multiple go-routines). This is useful since we can use the ReadFile function to return the content of the files which we ship with the binary.\nconst listHeight = 14 var ( titleStyle = lipgloss.NewStyle().MarginLeft(2) itemStyle = lipgloss.NewStyle().PaddingLeft(4) selectedItemStyle = lipgloss.NewStyle().PaddingLeft(2).Foreground(lipgloss.Color(\u0026#34;170\u0026#34;)) paginationStyle = list.DefaultStyles().PaginationStyle.PaddingLeft(4) helpStyle = list.DefaultStyles().HelpStyle.PaddingLeft(4).PaddingBottom(1) quitTextStyle = lipgloss.NewStyle().Margin(1, 0, 2, 4) ) This is used downstream to change the \u0026ldquo;style\u0026rdquo; of the list component from bubbles. The way the API is structured one cannot pass custom styles at the point of creating the component, therefore we must create a new instance of \u0026ldquo;style\u0026rdquo; using lipgloss.NewStyle() and then pass it to the appropriate variable in myList\u0026lt;list\u0026gt;.Style.\ntype item string\nHere we define an item of type String.\nfunc (i item) FilterValue() string { return \u0026quot;\u0026quot; }\nThe FilterValue() method is used to filter between each of the items. We need this because it is required by the list.Item interface. Even though we will later disable filtering (l.SetFilteringEnabled(false)), the interface still requires this method to be implemented. Without it, the code won\u0026rsquo;t compile.\nfunc (d itemDelegate) Height() int { return 1 } func (d itemDelegate) Spacing() int { return 0 } func (d itemDelegate) Update(_ tea.Msg, _ list.Model) tea.Cmd { return nil } The itemDelegate struct implements the list.ItemDelegate. This interface allows us to customize how individual items are displayed and behave within a list component.\nHeight() defines the vertical height of each list item (1 in our case). Spacing() is used to add blank lines appear between list items. (0 to make it compact). Update() handles messages specific to individual items. Parameters supplied here are tea.Msg and *list.Model which we will learn about later. func (d itemDelegate) Render(w io.Writer, m list.Model, index int, listItem list.Item) { i, ok := listItem.(item) if !ok { return } str := fmt.Sprintf(\u0026#34;%d. %s\u0026#34;, index+1, i.title) fn := itemStyle.Render if index == m.Index() { fn = func(s ...string) string { return selectedItemStyle.Render(\u0026#34;\u0026gt; \u0026#34; + strings.Join(s, \u0026#34; \u0026#34;)) } } fmt.Fprint(w, fn(str)) } This contains various parameters of types such as itemDelegate has d which is the receiver to struct (covered earlier). We supply the output through io.Writer where rendered text will be written.\nlist.Model displays the parent list state (which item is selected). i, ok := listItem.(item) This is Go\u0026rsquo;s type assertion feature. list.Item allows us to access fields like .title and .filename. If value of i is returned true, conversion has succeeded otherwise it means the type is wrong.\nstr := fmt.Sprintf(\u0026quot;%d. %s\u0026quot;, index+1, i.title) Here, we format the display string for providing us with options. i.title is used to display the form of text displayed (Matrix, Great Work, etc). We use index+1 to add human friendly numbering beginning from 1.\nfn := itemStyle.Render We use .Render for an item style that takes a string and returns a styled string. m.Index() simply returns the currently selected item\u0026rsquo;s index in the list. When selected, fn is triggered to add variadic parameter in s ...string.\nselectedItemStyle.Render(\u0026quot;\u0026gt; \u0026quot; + strings.Join(s, \u0026quot; \u0026quot;)) Render applies the selected item style (purple color + 2 spaces padding). Under strings.Join(), we simply prepend the arrow to the joined string to produce an output such as : \u0026quot;\u0026gt; 1. Great Work\u0026quot;.\nfmt.Fprint(w, fn(str)) Selects fn containing the formatted string and returns a styled version of it. w writes the string to io.Writer for obtaining output.\nfunc (m model) Init() tea.Cmd { if m.viewing { return tick() } return nil } func tick() tea.Cmd { return tea.Tick(time.Millisecond*80, func(t time.Time) tea.Msg { return tickMsg(t) }) } From a broad view, these two functions work together to implement animation timing in the Bubble Tea framework. They create a recurring \u0026ldquo;heartbeat\u0026rdquo; that drives the matrix rain effect.\nreturn tick performs on the boolean true result of m.viewing. tick starts the animation otherwise returns nil if boolean false.\ntick() tea.Cmd has a command output structure. It waits 80 milliseconds, sends a tickMsg back to the application and triggers next animation frame. 80ms is the sweet spot as it is smooth and consumes less CPU resources. tickMsg is a basic signal that says \u0026ldquo;show next frame\u0026rdquo;.\nfunc (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) { switch msg := msg.(type) { case tea.WindowSizeMsg: m.width = msg.Width m.height = msg.Height if m.list.Items() != nil { m.list.SetWidth(msg.Width) } if m.viewing { m.initColumns() } return m, nil We implement the Update method here to process every single thing that happens (key press, window resize, timer tick, etc). To figure out the exact kind of message sent, we implement the switch msg := msg.(type). In this particular case, we work with tea.WindowSizeMsg focusing on dragging to the corner to make it bigger or smaller via msg.Width and msg Height which adapts accordingly. Next we check whether it is in m.viewing mode, if it is, the Columns are recalculated based on new dimensions.\ncase tea.KeyMsg: switch keypress := msg.String(); keypress { case \u0026#34;q\u0026#34;, \u0026#34;ctrl+c\u0026#34;: if m.viewing { // If there\u0026#39;s no list (direct mode), quit entirely if m.list.Items() == nil { m.quitting = true return m, tea.Quit } // Otherwise return to list m.viewing = false m.choice = \u0026#34;\u0026#34; return m, nil } m.quitting = true return m, tea.Quit case \u0026#34;enter\u0026#34;: if !m.viewing \u0026amp;\u0026amp; m.list.Items() != nil { i, ok := m.list.SelectedItem().(item) if ok { m.choice = i.filename content, err := readAsset(m.choice) if err != nil { m.content = fmt.Sprintf(\u0026#34;Error: %v\u0026#34;, err) } else { m.content = content } m.viewing = true m.initColumns() return m, tick() } } } case tickMsg: if m.viewing { m.updateColumns() return m, tick() } } var cmd tea.Cmd if m.list.Items() != nil { m.list, cmd = m.list.Update(msg) } return m, cmd } Here we have a set of cases defining various actions. case \u0026quot;q\u0026quot;, \u0026quot;ctrl+c\u0026quot;: simply quits the instance and clears the screen, but we check whether is being viewed or not first. If the m.quitting is true, View() shows the quit message Quitting is for losers! (which is indeed true).\ncase \u0026quot;enter\u0026quot;: When you press Enter, it first checks whether it is being viewed and has a list, This makes sure we\u0026rsquo;re in the file selection screen where Enter should actually do something. If both conditions are true, it tries to get the currently selected item from the list using m.list.SelectedItem().(item). That type assertion might fail if something weird happened, we use the , ok idiom to safely check. If it successfully got the selected item, now the fun begins. We grab the filename (i.filename), try to read the file\u0026rsquo;s content using readAsset(), and handle any errors gracefully by storing a Error : %v message.\nEvery 80 milliseconds while the animation is running, it receives a tickMsg. This is the cue to advance the animation by one frame. It checks if m.viewing to make sure we\u0026rsquo;re still in viewing mode (the user might have pressed \u0026lsquo;q\u0026rsquo; to go back to the list), and if so, it calls m.updateColumns() which moves each column\u0026rsquo;s offset forward, creating the scrolling effect.\nfunc (m *model) initColumns() { if m.width == 0 || len(m.content) == 0 { return } numCols := m.width / 2 if numCols \u0026lt; 1 { numCols = 1 } m.columns = make([]column, numCols) runes := []rune(m.content) for i := range m.columns { m.columns[i] = column{ x: i * 2, height: rand.Intn(m.height) + 5, offset: rand.Intn(len(runes)), } } } func (m *model) updateColumns() { runes := []rune(m.content) if len(runes) == 0 { return } for i := range m.columns { m.columns[i].offset++ if m.columns[i].offset \u0026gt;= len(runes) { m.columns[i].offset = 0 } if rand.Float32() \u0026lt; 0.02 { m.columns[i].height = rand.Intn(m.height) + 5 } } } initColumns() sets up all the columns first \u0026ndash; it\u0026rsquo;s like setting the stage before show begins. For sanity check, we use m.width == 0 || len(m.content) == 0. We then divide the terminal width by 2 (numCols := m.width / 2). Why 2? Because we want to space the columns out, creating gaps between cascading characters.\nNext, we allocate memory for all these columns using make([]column, numCols). We then convert the entire file content into runes []rune(m.content) to properly handle emojis, Chinese, Arabic characters or other Unicode content. rand.Intn(m.height) gives a random number between 0 and the terminal height, then we add 5 to ensure every column is at least 5 characters tall. The offset is also randomized rand.Intn(len(runes)). This determines where in the text file each column starts reading.\nThen we loop through every single column created and update it. For each column, we increment its offset by m.columns[i].offset++. Now, if the offset has reached or exceeded the length of the runes array, we wrap it back to zero (m.columns[i].offset = 0). This creates an infinite loop through the content. It\u0026rsquo;s like a circular buffer.\nEvery frame, for each column, we roll the dice with a 2% chance rand.Float32() \u0026lt; 0.02. Think about it: rand.Float32() gives me a random number between 0.0 and 1.0.\nfunc (m model) View() string { if m.viewing { return m.matrixView() } if m.quitting { return quitTextStyle.Render(\u0026#34;Quitting is for losers.\u0026#34;) } if m.list.Items() != nil { return \u0026#34;\\n\u0026#34; + m.list.View() } return \u0026#34;\u0026#34; } func (m model) matrixView() string { if len(m.columns) == 0 || len(m.content) == 0 { return \u0026#34;\u0026#34; } grid := make([][]rune, m.height) for i := range grid { grid[i] = make([]rune, m.width) for j := range grid[i] { grid[i][j] = \u0026#39; \u0026#39; } } runes := []rune(m.content) for _, col := range m.columns { if col.x \u0026gt;= m.width { continue } for row := 0; row \u0026lt; col.height \u0026amp;\u0026amp; row \u0026lt; m.height; row++ { charIdx := (col.offset + row) % len(runes) if charIdx \u0026lt; 0 { charIdx += len(runes) } if row \u0026lt; m.height \u0026amp;\u0026amp; col.x \u0026lt; m.width { grid[row][col.x] = runes[charIdx] } } } var result strings.Builder for rowIdx, row := range grid { for _, char := range row { if char != \u0026#39; \u0026#39; { color := getRandomColor() style := lipgloss.NewStyle().Foreground(lipgloss.Color(color)) result.WriteString(style.Render(string(char))) } else { result.WriteRune(\u0026#39; \u0026#39;) } } if rowIdx \u0026lt; len(grid)-1 { result.WriteString(\u0026#34;\\n\u0026#34;) } } return result.String() } Further, we proceed to displaying the rain on terminal screen. We achieve this by using View() with various conditions. If m.viewing is true, the matrixView() creates the rain effect, if not we let the user quit because we assume they are a loser xD. If the user is not viewing and not quitting, then they must be in list mode. We check if the list exists m.list.Items() != nil, and if so, return the list\u0026rsquo;s view with a newline prepended.\nNow, here\u0026rsquo;s the big idea: We create a 2D grid that represents every single character position on the screen. Think of it like graph paper where each cell can hold one character. We create this grid using make([][]rune, m.height) which gives a slice of slices - essentially a 2D array where the first dimension is rows (height) and the second is columns (width).\nWe iterate through all the columns. For each column, we first check if its x-position is off the screen (col.x \u0026gt;= m.width). If someone resized the window smaller after the columns were created, some columns might be positioned beyond the right edge. We skip those with continue because trying to draw them would cause an out-of-bounds error.\nNext, we initialize this entire grid to spaces. Allocate space for m.width and fill all positions with ' '. This creates a blank canvas. Let\u0026rsquo;s break down (col.offset + row) % len(runes). On adding the offset and row we get a position in the source text. The % wraps the index around if it exceeds the text length. This creates that circular buffer effect where columns seamlessly loop through the content.\nWe then use a strings.Builder which is Go\u0026rsquo;s efficient way of building strings piece by piece. If the character is NOT a space, we generate a random color, create a Lipgloss style with that color, and render the character with that styling. Finally, result.String gives us the beautiful rain effect as a single string!\nExtensions So, while almost finishing the initial stages of matrix in go in the back of my mind I thought why not to increase the complexity xD. Here I go (pun intended): Image to ASCII Negatives Star Wars intro theme rendered into the terminal. ","permalink":"https://isopath.github.io/isopath.github.io/pr-preview/pr-1/posts/matrix-go/","summary":"\u003cp\u003eRepository: \u003ca href=\"https://github.com/isopath/matrix.go\"\u003ehttps://github.com/isopath/matrix.go\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003ccode\u003e//go:embed\u003c/code\u003e directive allows programs to include arbitrary files in the go binary at build time.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e//go:embed assets/*.txt\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eassetsFS\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eembed\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eFS\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWe use this to include all the text files from the \u003ccode\u003eassets/\u003c/code\u003e directory (used for the text for rain). All values are stored in the variable \u003ccode\u003eassetsFS\u003c/code\u003e of type \u003ca href=\"https://pkg.go.dev/embed#FS\"\u003e\u003ccode\u003eembed.FS\u003c/code\u003e\u003c/a\u003e, a read-only collection of files (allowing for use with multiple go-routines). This is useful since we can use the \u003ccode\u003eReadFile\u003c/code\u003e function to return the content of the files which we ship with the binary.\u003c/p\u003e","title":"matrix.go"}]