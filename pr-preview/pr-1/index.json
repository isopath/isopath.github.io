[{"content":"Welcome to our implementation of what we imagined will be a fun project of making rain in the terminal. Then we couldn\u0026rsquo;t figure out how so we asked opencode. The following is what we (us and OC) came up with.\nLet\u0026rsquo;s Begin We are using the approach of analyzing code snippets in order of the flow. Usage of what and why is done for each part of the code explanation.\nInitialisation //go:embed directive allows programs to include arbitrary files in the go binary at build time.\n//go:embed assets/*.txt var assetsFS embed.FS We use this to include all the text files from the assets/ directory (used for the text for rain). All values are stored in the variable assetsFS of type embed.FS, a read-only collection of files (allowing for use with multiple go-routines). This is useful since we can use the ReadFile function to return the content of the files which we ship with the binary.\nconst listHeight = 14 var ( titleStyle = lipgloss.NewStyle().MarginLeft(2) itemStyle = lipgloss.NewStyle().PaddingLeft(4) selectedItemStyle = lipgloss.NewStyle().PaddingLeft(2).Foreground(lipgloss.Color(\u0026#34;170\u0026#34;)) paginationStyle = list.DefaultStyles().PaginationStyle.PaddingLeft(4) helpStyle = list.DefaultStyles().HelpStyle.PaddingLeft(4).PaddingBottom(1) quitTextStyle = lipgloss.NewStyle().Margin(1, 0, 2, 4) ) This is used downstream to change the \u0026ldquo;style\u0026rdquo; of the list component from bubbles. The way the API is structured one cannot pass custom styles at the point of creating the component, therefore we must create a new instance of \u0026ldquo;style\u0026rdquo; using lipgloss.NewStyle() and then pass it to the appropriate variable in myList\u0026lt;list\u0026gt;.Style.\ntype item string\nHere we define an item of type String.\nfunc (i item) FilterValue() string { return \u0026quot;\u0026quot; }\nThe FilterValue() method is used to filter between each of the items. We need this because it is required by the list.Item interface. Even though we will later disable filtering (l.SetFilteringEnabled(false)), the interface still requires this method to be implemented. Without it, the code won\u0026rsquo;t compile.\nfunc (d itemDelegate) Height() int { return 1 } func (d itemDelegate) Spacing() int { return 0 } func (d itemDelegate) Update(_ tea.Msg, _ *list.Model) tea.Cmd { return nil } The itemDelegate struct implements the list.ItemDelegate. This interface allows us to customize how individual items are displayed and behave within a list component.\nHeight() defines the vertical height of each list item (1 in our case). Spacing() is used to add blank lines appear between list items. (0 to make it compact). Update() handles messages specific to individual list items. Parameters supplied here are tea.Msg and *list.Model which we will learn about later. func (d itemDelegate) Render(w io.Writer, m list.Model, index int, listItem list.Item) { i, ok := listItem.(item) if !ok { return } str := fmt.Sprintf(\u0026#34;%d. %s\u0026#34;, index+1, i.title) fn := itemStyle.Render if index == m.Index() { fn = func(s ...string) string { return selectedItemStyle.Render(\u0026#34;\u0026gt; \u0026#34; + strings.Join(s, \u0026#34; \u0026#34;)) } } fmt.Fprint(w, fn(str)) } This contains various parameters of types such as itemDelegate has d which is the receiver to struct (covered earlier). We supply the output through io.Writer where rendered text will be written.\nlist.Model displays the parent list state (which item is selected). i, ok := listItem.(item) This is Go\u0026rsquo;s type assertion feature. list.Item allows us to access fields like .title and .filename. If value of i is returned true, conversion has succeeded otherwise it means the type is wrong.\nstr := fmt.Sprintf(\u0026quot;%d. %s\u0026quot;, index+1, i.title) Here, we format the display string for providing us with options. i.title is used to display the form of text displayed (Matrix, Great Work, etc). We use index+1 to add human friendly numbering beginning from 1.\nfn := itemStyle.Render We use .Render for an item style that takes a string and returns a styled string. m.Index() simply returns the currently selected item\u0026rsquo;s index in the list. When selected, fn is triggered to add variadic parameter in s ...string.\nselectedItemStyle.Render(\u0026quot;\u0026gt; \u0026quot; + strings.Join(s, \u0026quot; \u0026quot;)) Render applies the selected item style (purple color + 2 spaces padding). Under strings.Join(), we simply prepend the arrow to the joined string to produce an output such as : \u0026quot;\u0026gt; 1. Great Work\u0026quot;.\nfmt.Fprint(w, fn(str)) Selects fn containing the formatted string and returns a styled version of it. w writes the string to io.Writer for obtaining output.\nfunc (m model) Init() tea.Cmd { if m.viewing { return tick() } return nil } func tick() tea.Cmd { return tea.Tick(time.Millisecond*80, func(t time.Time) tea.Msg { return tickMsg(t) }) } From a broad view, these two functions work together to implement animation timing in the Bubble Tea framework. They create a recurring \u0026ldquo;heartbeat\u0026rdquo; that drives the matrix rain effect.\nreturn tick performs on the boolean true result of m.viewing. tick starts the animation otherwise returns nil if boolean false.\ntick() tea.Cmd has a command output structure. It waits 80 milliseconds, sends a tickMsg back to the application and triggers next animation frame. 80ms is the sweet spot as it is smooth and consumes less CPU resources. tickMsg is a basic signal that says \u0026ldquo;show next frame\u0026rdquo;.\nfunc (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) { switch msg := msg.(type) { case tea.WindowSizeMsg: m.width = msg.Width m.height = msg.Height if m.list.Items() != nil { m.list.SetWidth(msg.Width) } if m.viewing { m.initColumns() } return m, nil We implement the Update method here to process every single thing that happens (key press, window resize, timer tick, etc). To figure out the exact kind of message sent, we implement the switch msg := msg.(type). In this particular case, we work with tea.WindowSizeMsg focusing on dragging to the corner to make it bigger or smaller via msg.Width and msg Height which adapts accordingly. Next we check whether it is in m.viewing mode, if it is, the Columns are recalculated based on new dimensions.\ncase tea.KeyMsg: switch keypress := msg.String(); keypress { case \u0026#34;q\u0026#34;, \u0026#34;ctrl+c\u0026#34;: if m.viewing { // If there\u0026#39;s no list (direct mode), quit entirely if m.list.Items() == nil { m.quitting = true return m, tea.Quit } // Otherwise return to list m.viewing = false m.choice = \u0026#34;\u0026#34; return m, nil } m.quitting = true return m, tea.Quit case \u0026#34;enter\u0026#34;: if !m.viewing \u0026amp;\u0026amp; m.list.Items() != nil { i, ok := m.list.SelectedItem().(item) if ok { m.choice = i.filename content, err := readAsset(m.choice) if err != nil { m.content = fmt.Sprintf(\u0026#34;Error: %v\u0026#34;, err) } else { m.content = content } m.viewing = true m.initColumns() return m, tick() } } } case tickMsg: if m.viewing { m.updateColumns() return m, tick() } } var cmd tea.Cmd if m.list.Items() != nil { m.list, cmd = m.list.Update(msg) } return m, cmd } Here we have a set of cases defining various actions. case \u0026quot;q\u0026quot;, \u0026quot;ctrl+c\u0026quot;: simply quits the instance and clears the screen, but we check whether is being viewed or not first. If the m.quitting is true, View() shows the quit message Quitting is for losers! (which is indeed true).\ncase \u0026quot;enter\u0026quot;: When you press Enter, it first checks whether it is being viewed and has a list, This makes sure we\u0026rsquo;re in the file selection screen where Enter should actually do something. If both conditions are true, it tries to get the currently selected item from the list using m.list.SelectedItem().(item). That type assertion might fail if something weird happened, we use the , ok idiom to safely check. If it successfully got the selected item, now the fun begins. We grab the filename (i.filename), try to read the file\u0026rsquo;s content using readAsset(), and handle any errors gracefully by storing a Error : %v message.\nEvery 80 milliseconds while the animation is running, it receives a tickMsg. This is the cue to advance the animation by one frame. It checks if m.viewing to make sure we\u0026rsquo;re still in viewing mode (the user might have pressed \u0026lsquo;q\u0026rsquo; to go back to the list), and if so, it calls m.updateColumns() which moves each column\u0026rsquo;s offset forward, creating the scrolling effect.\nfunc (m *model) initColumns() { if m.width == 0 || len(m.content) == 0 { return } numCols := m.width / 2 if numCols \u0026lt; 1 { numCols = 1 } m.columns = make([]column, numCols) runes := []rune(m.content) for i := range m.columns { m.columns[i] = column{ x: i * 2, height: rand.Intn(m.height) + 5, offset: rand.Intn(len(runes)), } } } func (m *model) updateColumns() { runes := []rune(m.content) if len(runes) == 0 { return } for i := range m.columns { m.columns[i].offset++ if m.columns[i].offset \u0026gt;= len(runes) { m.columns[i].offset = 0 } if rand.Float32() \u0026lt; 0.02 { m.columns[i].height = rand.Intn(m.height) + 5 } } } initColumns() sets up all the columns first \u0026ndash; it\u0026rsquo;s like setting the stage before show begins. For sanity check, we use m.width == 0 || len(m.content) == 0. We then divide the terminal width by 2 (numCols := m.width / 2). Why 2? Because we want to space the columns out, creating gaps between cascading characters.\nNext, we allocate memory for all these columns using make([]column, numCols). We then convert the entire file content into runes []rune(m.content) to properly handle emojis, Chinese, Arabic characters or other Unicode content. rand.Intn(m.height) gives a random number between 0 and the terminal height, then we add 5 to ensure every column is at least 5 characters tall. The offset is also randomized rand.Intn(len(runes)). This determines where in the text file each column starts reading.\nThen we loop through every single column created and update it. For each column, we increment its offset by m.columns[i].offset++. Now, if the offset has reached or exceeded the length of the runes array, we wrap it back to zero (m.columns[i].offset = 0). This creates an infinite loop through the content. It\u0026rsquo;s like a circular buffer.\nEvery frame, for each column, we roll the dice with a 2% chance rand.Float32() \u0026lt; 0.02. Think about it: rand.Float32() gives me a random number between 0.0 and 1.0.\nfunc (m model) View() string { if m.viewing { return m.matrixView() } if m.quitting { return quitTextStyle.Render(\u0026#34;Quitting is for losers.\u0026#34;) } if m.list.Items() != nil { return \u0026#34;\\n\u0026#34; + m.list.View() } return \u0026#34;\u0026#34; } func (m model) matrixView() string { if len(m.columns) == 0 || len(m.content) == 0 { return \u0026#34;\u0026#34; } grid := make([][]rune, m.height) for i := range grid { grid[i] = make([]rune, m.width) for j := range grid[i] { grid[i][j] = \u0026#39; \u0026#39; } } runes := []rune(m.content) for _, col := range m.columns { if col.x \u0026gt;= m.width { continue } for row := 0; row \u0026lt; col.height \u0026amp;\u0026amp; row \u0026lt; m.height; row++ { charIdx := (col.offset + row) % len(runes) if charIdx \u0026lt; 0 { charIdx += len(runes) } if row \u0026lt; m.height \u0026amp;\u0026amp; col.x \u0026lt; m.width { grid[row][col.x] = runes[charIdx] } } } var result strings.Builder for rowIdx, row := range grid { for _, char := range row { if char != \u0026#39; \u0026#39; { color := getRandomColor() style := lipgloss.NewStyle().Foreground(lipgloss.Color(color)) result.WriteString(style.Render(string(char))) } else { result.WriteRune(\u0026#39; \u0026#39;) } } if rowIdx \u0026lt; len(grid)-1 { result.WriteString(\u0026#34;\\n\u0026#34;) } } return result.String() } Further, we proceed to displaying the rain on terminal screen. We achieve this by using View() with various conditions. If m.viewing is true, the matrixView() creates the rain effect, if not we let the user quit because we assume they are a loser xD. If the user is not viewing and not quitting, then they must be in list mode. We check if the list exists m.list.Items() != nil, and if so, return the list\u0026rsquo;s view with a newline prepended.\nNow, here\u0026rsquo;s the big idea: We create a 2D grid that represents every single character position on the screen. Think of it like graph paper where each cell can hold one character. We create this grid using make([][]rune, m.height) which gives a slice of slices - essentially a 2D array where the first dimension is rows (height) and the second is columns (width).\nWe iterate through all the columns. For each column, we first check if its x-position is off the screen (col.x \u0026gt;= m.width). If someone resized the window smaller after the columns were created, some columns might be positioned beyond the right edge. We skip those with continue because trying to draw them would cause an out-of-bounds error.\nNext, we initialize this entire grid to spaces. Allocate space for m.width and fill all positions with ' '. This creates a blank canvas. Let\u0026rsquo;s break down (col.offset + row) % len(runes). On adding the offset and row we get a position in the source text. The % wraps the index around if it exceeds the text length. This creates that circular buffer effect where columns seamlessly loop through the content.\nWe then use a strings.Builder which is Go\u0026rsquo;s efficient way of building strings piece by piece. If the character is NOT a space, we generate a random color, create a Lipgloss style with that color, and render the character with that styling. Finally, result.String gives us the beautiful rain effect as a single string!\nfunc getRandomColor() string { colors := []string{ \u0026#34;196\u0026#34;, \u0026#34;197\u0026#34;, \u0026#34;198\u0026#34;, \u0026#34;199\u0026#34;, \u0026#34;200\u0026#34;, \u0026#34;201\u0026#34;, // pinks/magentas \u0026#34;160\u0026#34;, \u0026#34;161\u0026#34;, \u0026#34;162\u0026#34;, \u0026#34;163\u0026#34;, \u0026#34;164\u0026#34;, \u0026#34;165\u0026#34;, // reds \u0026#34;202\u0026#34;, \u0026#34;203\u0026#34;, \u0026#34;204\u0026#34;, \u0026#34;205\u0026#34;, \u0026#34;206\u0026#34;, \u0026#34;207\u0026#34;, // oranges \u0026#34;208\u0026#34;, \u0026#34;209\u0026#34;, \u0026#34;210\u0026#34;, \u0026#34;211\u0026#34;, \u0026#34;212\u0026#34;, \u0026#34;213\u0026#34;, // light oranges \u0026#34;214\u0026#34;, \u0026#34;215\u0026#34;, \u0026#34;216\u0026#34;, \u0026#34;217\u0026#34;, \u0026#34;218\u0026#34;, \u0026#34;219\u0026#34;, // yellows \u0026#34;220\u0026#34;, \u0026#34;221\u0026#34;, \u0026#34;222\u0026#34;, \u0026#34;223\u0026#34;, \u0026#34;224\u0026#34;, \u0026#34;225\u0026#34;, // light yellows \u0026#34;226\u0026#34;, \u0026#34;227\u0026#34;, \u0026#34;228\u0026#34;, \u0026#34;229\u0026#34;, \u0026#34;230\u0026#34;, \u0026#34;231\u0026#34;, // whites \u0026#34;82\u0026#34;, \u0026#34;83\u0026#34;, \u0026#34;84\u0026#34;, \u0026#34;85\u0026#34;, \u0026#34;86\u0026#34;, \u0026#34;87\u0026#34;, // greens \u0026#34;28\u0026#34;, \u0026#34;29\u0026#34;, \u0026#34;30\u0026#34;, \u0026#34;31\u0026#34;, \u0026#34;32\u0026#34;, \u0026#34;33\u0026#34;, // dark greens \u0026#34;40\u0026#34;, \u0026#34;41\u0026#34;, \u0026#34;42\u0026#34;, \u0026#34;43\u0026#34;, \u0026#34;44\u0026#34;, \u0026#34;45\u0026#34;, // cyans \u0026#34;46\u0026#34;, \u0026#34;47\u0026#34;, \u0026#34;48\u0026#34;, \u0026#34;49\u0026#34;, \u0026#34;50\u0026#34;, \u0026#34;51\u0026#34;, // teals \u0026#34;75\u0026#34;, \u0026#34;76\u0026#34;, \u0026#34;77\u0026#34;, \u0026#34;78\u0026#34;, \u0026#34;79\u0026#34;, \u0026#34;80\u0026#34;, // blues \u0026#34;63\u0026#34;, \u0026#34;64\u0026#34;, \u0026#34;65\u0026#34;, \u0026#34;66\u0026#34;, \u0026#34;67\u0026#34;, \u0026#34;68\u0026#34;, // dark blues \u0026#34;90\u0026#34;, \u0026#34;91\u0026#34;, \u0026#34;92\u0026#34;, \u0026#34;93\u0026#34;, \u0026#34;94\u0026#34;, \u0026#34;95\u0026#34;, // purples \u0026#34;129\u0026#34;, \u0026#34;130\u0026#34;, \u0026#34;131\u0026#34;, \u0026#34;132\u0026#34;, \u0026#34;133\u0026#34;, \u0026#34;134\u0026#34;, // violets \u0026#34;141\u0026#34;, \u0026#34;142\u0026#34;, \u0026#34;143\u0026#34;, \u0026#34;144\u0026#34;, \u0026#34;145\u0026#34;, \u0026#34;146\u0026#34;, // light purples } return colors[rand.Intn(len(colors))] } func readAsset(filename string) (string, error) { data, err := assetsFS.ReadFile(filename) if err != nil { return \u0026#34;\u0026#34;, err } return string(data), nil } func getAvailableFiles() []string { files := []string{} entries, err := assetsFS.ReadDir(\u0026#34;assets\u0026#34;) if err != nil { return files } for _, entry := range entries { if !entry.IsDir() \u0026amp;\u0026amp; strings.HasSuffix(entry.Name(), \u0026#34;.txt\u0026#34;) { files = append(files, \u0026#34;assets/\u0026#34;+entry.Name()) } } return files } getRandomColor() maintains a carefully curated palette of 96 colors, organized into logical groups spanning the full spectrum. The selection mechanism is elegantly simple: rand.Intn(len(colors)) generates a random integer between zero and the length of the slice, which then serves as an index to retrieve a color code.\nThe readAsset() function is the gateway to loading resources efficiently, this reads a file from an embedded filesystem assetsFS and returns its contents as a string. If the file can’t be read, it propagates the error for graceful handling. ReadFile(filename string) Attempts to read the specified file from the embedded filesystem.\n!entry.IsDir() → Ensures we only process files, not subdirectories. For each valid file, it constructs the full path: \u0026quot;assets/\u0026quot; + entry.Name()\nfunc main() { rand.Seed(time.Now().UnixNano()) var showOptions bool var filePath string flag.BoolVar(\u0026amp;showOptions, \u0026#34;options\u0026#34;, false, \u0026#34;Show list of available files to choose from\u0026#34;) flag.StringVar(\u0026amp;filePath, \u0026#34;file\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Path to a specific .txt file to display\u0026#34;) flag.Parse() // Default: show matrix directly with greatwork.txt targetFile := \u0026#34;assets/greatwork.txt\u0026#34; if filePath != \u0026#34;\u0026#34; { // User specified a file targetFile = filePath // If it\u0026#39;s not a path with assets/, assume it\u0026#39;s in assets/ if !strings.Contains(targetFile, \u0026#34;/\u0026#34;) \u0026amp;\u0026amp; !strings.HasPrefix(targetFile, \u0026#34;assets/\u0026#34;) { targetFile = \u0026#34;assets/\u0026#34; + targetFile } } if showOptions { // Show list widget files := getAvailableFiles() if len(files) == 0 { fmt.Println(\u0026#34;No .txt files found in assets\u0026#34;) os.Exit(1) } var items []list.Item for _, f := range files { title := f // Convert filename to friendly title title = strings.TrimPrefix(title, \u0026#34;assets/\u0026#34;) title = strings.TrimSuffix(title, \u0026#34;.txt\u0026#34;) title = strings.ReplaceAll(title, \u0026#34;-\u0026#34;, \u0026#34; \u0026#34;) // Capitalize words words := strings.Split(title, \u0026#34; \u0026#34;) for i, word := range words { if len(word) \u0026gt; 0 { words[i] = strings.ToUpper(word[:1]) + word[1:] } } title = strings.Join(words, \u0026#34; \u0026#34;) items = append(items, item{title: title, filename: f}) } const defaultWidth = 20 l := list.New(items, itemDelegate{}, defaultWidth, listHeight) l.Title = \u0026#34;Choose text:\u0026#34; l.SetShowStatusBar(false) l.SetFilteringEnabled(false) l.Styles.Title = titleStyle l.Styles.PaginationStyle = paginationStyle l.Styles.HelpStyle = helpStyle m := model{list: l} if _, err := tea.NewProgram(m).Run(); err != nil { fmt.Println(\u0026#34;Error running program:\u0026#34;, err) os.Exit(1) } } else { // Direct matrix view content, err := readAsset(targetFile) if err != nil { // Try reading from filesystem as fallback data, err2 := os.ReadFile(targetFile) if err2 != nil { fmt.Printf(\u0026#34;Error reading file %s: %v\\n\u0026#34;, targetFile, err) os.Exit(1) } content = string(data) } m := model{ content: content, viewing: true, } if _, err := tea.NewProgram(m).Run(); err != nil { fmt.Println(\u0026#34;Error running program:\u0026#34;, err) os.Exit(1) } } } The very first line does something subtle but important: rand.Seed(time.Now().UnixNano()) . We\u0026rsquo;re seeding Go\u0026rsquo;s random number generator with the current time in nanoseconds. That cascading matrix effect needs unpredictability to feel alive and organic. By using the current timestamp, we ensure that each run produces a unique visual experience.\nNext, we set up our command-line flags - the arguments users can pass when launching the program: var showOptions bool, giving us three ways to run it:\nSimple Launch via ./program. File Selection Mode ./program --options Direct File Mode ./program --file philosophy.txt If someone types ./program --file mytext.txt, we automatically assume they mean assets/mytext.txt. But if they provide a full path like /home/user/documents/poem.txt, we use it exactly as given. When the user launches with --options, we enter list mode under showOptions().\nA file named assets/the-philosophy-of-time.txt becomes \u0026ldquo;The Philosophy Of Time\u0026rdquo; in the display by using strings.ToUpper(word[:1]) + word[1:]. We\u0026rsquo;re not just showing raw filenames - we\u0026rsquo;re presenting them in a way that respects the user.\nBuilding the List Widget:\n`const defaultWidth = 20 l := list.New(items, itemDelegate{}, defaultWidth, listHeight) We\u0026rsquo;re configuring the Bubble Tea list component with sensible defaults. Filtering is off because with a handful of text files, simple arrow key navigation suffices. The styling assignments connect our global style definitions (like titleStyle and paginationStyle) to the list component. Launching the List Experience:\nm := model{list: l} We create a model with just the list (no content, not viewing yet), wrap it in a Bubble Tea program, and run it. The program blocks here, handling all user interaction, until the user quits or selects a file. The goal we should all strive for: code that works correctly, fails gracefully, and reads like a story. When someone new comes to this codebase, they can read main() top to bottom and understand exactly what the program does and how to use it.\n","permalink":"https://isopath.github.io/posts/matrix-go/","summary":"\u003cp\u003eWelcome to our implementation of what we imagined will be a fun project of making rain in the terminal. Then we couldn\u0026rsquo;t figure out how so we asked \u003ca href=\"https://opencode.ai/\"\u003eopencode\u003c/a\u003e. The following is what we (us and OC) came up with.\u003c/p\u003e\n\u003ch2 id=\"lets-begin\"\u003eLet\u0026rsquo;s Begin\u003c/h2\u003e\n\u003cp\u003eWe are using the approach of analyzing code snippets in order of the flow. Usage of what and why is done for each part of the code explanation.\u003c/p\u003e\n\u003ch2 id=\"initialisation\"\u003eInitialisation\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e//go:embed\u003c/code\u003e directive allows programs to include arbitrary files in the go binary at build time.\u003c/p\u003e","title":"matrix.go"}]