<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>matrix.go | isopath</title>
<meta name=keywords content="go,bubbletea,terminal,tui"><meta name=description content="Repository: https://github.com/isopath/matrix.go

//go:embed directive allows programs to include arbitrary files in the go binary at build time.
//go:embed assets/*.txt
var assetsFS embed.FS
We use this to include all the text files from the assets/ directory (used for the text for rain). All values are stored in the variable assetsFS of type embed.FS, a read-only collection of files (allowing for use with multiple go-routines). This is useful since we can use the ReadFile function to return the content of the files which we ship with the binary."><meta name=author content><link rel=canonical href=https://isopath.github.io/posts/matrix-go/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://isopath.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://isopath.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://isopath.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://isopath.github.io/apple-touch-icon.png><link rel=mask-icon href=https://isopath.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://isopath.github.io/posts/matrix-go/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://isopath.github.io/posts/matrix-go/"><meta property="og:site_name" content="isopath"><meta property="og:title" content="matrix.go"><meta property="og:description" content="Repository: https://github.com/isopath/matrix.go
//go:embed directive allows programs to include arbitrary files in the go binary at build time.
//go:embed assets/*.txt var assetsFS embed.FS We use this to include all the text files from the assets/ directory (used for the text for rain). All values are stored in the variable assetsFS of type embed.FS, a read-only collection of files (allowing for use with multiple go-routines). This is useful since we can use the ReadFile function to return the content of the files which we ship with the binary."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-05T14:00:00+00:00"><meta property="article:modified_time" content="2025-02-05T14:00:00+00:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Bubbletea"><meta property="article:tag" content="Terminal"><meta property="article:tag" content="Tui"><meta name=twitter:card content="summary"><meta name=twitter:title content="matrix.go"><meta name=twitter:description content="Repository: https://github.com/isopath/matrix.go

//go:embed directive allows programs to include arbitrary files in the go binary at build time.
//go:embed assets/*.txt
var assetsFS embed.FS
We use this to include all the text files from the assets/ directory (used for the text for rain). All values are stored in the variable assetsFS of type embed.FS, a read-only collection of files (allowing for use with multiple go-routines). This is useful since we can use the ReadFile function to return the content of the files which we ship with the binary."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://isopath.github.io/posts/"},{"@type":"ListItem","position":2,"name":"matrix.go","item":"https://isopath.github.io/posts/matrix-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"matrix.go","name":"matrix.go","description":"Repository: https://github.com/isopath/matrix.go\n//go:embed directive allows programs to include arbitrary files in the go binary at build time.\n//go:embed assets/*.txt var assetsFS embed.FS We use this to include all the text files from the assets/ directory (used for the text for rain). All values are stored in the variable assetsFS of type embed.FS, a read-only collection of files (allowing for use with multiple go-routines). This is useful since we can use the ReadFile function to return the content of the files which we ship with the binary.\n","keywords":["go","bubbletea","terminal","tui"],"articleBody":"Repository: https://github.com/isopath/matrix.go\n//go:embed directive allows programs to include arbitrary files in the go binary at build time.\n//go:embed assets/*.txt var assetsFS embed.FS We use this to include all the text files from the assets/ directory (used for the text for rain). All values are stored in the variable assetsFS of type embed.FS, a read-only collection of files (allowing for use with multiple go-routines). This is useful since we can use the ReadFile function to return the content of the files which we ship with the binary.\nconst listHeight = 14 var ( titleStyle = lipgloss.NewStyle().MarginLeft(2) itemStyle = lipgloss.NewStyle().PaddingLeft(4) selectedItemStyle = lipgloss.NewStyle().PaddingLeft(2).Foreground(lipgloss.Color(\"170\")) paginationStyle = list.DefaultStyles().PaginationStyle.PaddingLeft(4) helpStyle = list.DefaultStyles().HelpStyle.PaddingLeft(4).PaddingBottom(1) quitTextStyle = lipgloss.NewStyle().Margin(1, 0, 2, 4) ) This is used downstream to change the “style” of the list component from bubbles. The way the API is structured one cannot pass custom styles at the point of creating the component, therefore we must create a new instance of “style” using lipgloss.NewStyle() and then pass it to the appropriate variable in myList.Style.\ntype item string\nHere we define an item of type String.\nfunc (i item) FilterValue() string { return \"\" }\nThe FilterValue() method is used to filter between each of the items. We need this because it is required by the list.Item interface. Even though we will later disable filtering (l.SetFilteringEnabled(false)), the interface still requires this method to be implemented. Without it, the code won’t compile.\nfunc (d itemDelegate) Height() int { return 1 } func (d itemDelegate) Spacing() int { return 0 } func (d itemDelegate) Update(_ tea.Msg, _ list.Model) tea.Cmd { return nil } The itemDelegate struct implements the list.ItemDelegate. This interface allows us to customize how individual items are displayed and behave within a list component.\nHeight() defines the vertical height of each list item (1 in our case). Spacing() is used to add blank lines appear between list items. (0 to make it compact). Update() handles messages specific to individual items. Parameters supplied here are tea.Msg and *list.Model which we will learn about later. func (d itemDelegate) Render(w io.Writer, m list.Model, index int, listItem list.Item) { i, ok := listItem.(item) if !ok { return } str := fmt.Sprintf(\"%d. %s\", index+1, i.title) fn := itemStyle.Render if index == m.Index() { fn = func(s ...string) string { return selectedItemStyle.Render(\"\u003e \" + strings.Join(s, \" \")) } } fmt.Fprint(w, fn(str)) } This contains various parameters of types such as itemDelegate has d which is the receiver to struct (covered earlier). We supply the output through io.Writer where rendered text will be written.\nlist.Model displays the parent list state (which item is selected). i, ok := listItem.(item) This is Go’s type assertion feature. list.Item allows us to access fields like .title and .filename. If value of i is returned true, conversion has succeeded otherwise it means the type is wrong.\nstr := fmt.Sprintf(\"%d. %s\", index+1, i.title) Here, we format the display string for providing us with options. i.title is used to display the form of text displayed (Matrix, Great Work, etc). We use index+1 to add human friendly numbering beginning from 1.\nfn := itemStyle.Render We use .Render for an item style that takes a string and returns a styled string. m.Index() simply returns the currently selected item’s index in the list. When selected, fn is triggered to add variadic parameter in s ...string.\nselectedItemStyle.Render(\"\u003e \" + strings.Join(s, \" \")) Render applies the selected item style (purple color + 2 spaces padding). Under strings.Join(), we simply prepend the arrow to the joined string to produce an output such as : \"\u003e 1. Great Work\".\nfmt.Fprint(w, fn(str)) Selects fn containing the formatted string and returns a styled version of it. w writes the string to io.Writer for obtaining output.\nfunc (m model) Init() tea.Cmd { if m.viewing { return tick() } return nil } func tick() tea.Cmd { return tea.Tick(time.Millisecond*80, func(t time.Time) tea.Msg { return tickMsg(t) }) } From a broad view, these two functions work together to implement animation timing in the Bubble Tea framework. They create a recurring “heartbeat” that drives the matrix rain effect.\nreturn tick performs on the boolean true result of m.viewing. tick starts the animation otherwise returns nil if boolean false.\ntick() tea.Cmd has a command output structure. It waits 80 milliseconds, sends a tickMsg back to the application and triggers next animation frame. 80ms is the sweet spot as it is smooth and consumes less CPU resources. tickMsg is a basic signal that says “show next frame”.\nfunc (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) { switch msg := msg.(type) { case tea.WindowSizeMsg: m.width = msg.Width m.height = msg.Height if m.list.Items() != nil { m.list.SetWidth(msg.Width) } if m.viewing { m.initColumns() } return m, nil We implement the Update method here to process every single thing that happens (key press, window resize, timer tick, etc). To figure out the exact kind of message sent, we implement the switch msg := msg.(type). In this particular case, we work with tea.WindowSizeMsg focusing on dragging to the corner to make it bigger or smaller via msg.Width and msg Height which adapts accordingly. Next we check whether it is in m.viewing mode, if it is, the Columns are recalculated based on new dimensions.\ncase tea.KeyMsg: switch keypress := msg.String(); keypress { case \"q\", \"ctrl+c\": if m.viewing { // If there's no list (direct mode), quit entirely if m.list.Items() == nil { m.quitting = true return m, tea.Quit } // Otherwise return to list m.viewing = false m.choice = \"\" return m, nil } m.quitting = true return m, tea.Quit case \"enter\": if !m.viewing \u0026\u0026 m.list.Items() != nil { i, ok := m.list.SelectedItem().(item) if ok { m.choice = i.filename content, err := readAsset(m.choice) if err != nil { m.content = fmt.Sprintf(\"Error: %v\", err) } else { m.content = content } m.viewing = true m.initColumns() return m, tick() } } } case tickMsg: if m.viewing { m.updateColumns() return m, tick() } } var cmd tea.Cmd if m.list.Items() != nil { m.list, cmd = m.list.Update(msg) } return m, cmd } Here we have a set of cases defining various actions. case \"q\", \"ctrl+c\": simply quits the instance and clears the screen, but we check whether is being viewed or not first. If the m.quitting is true, View() shows the quit message Quitting is for losers! (which is indeed true).\ncase \"enter\": When you press Enter, it first checks whether it is being viewed and has a list, This makes sure we’re in the file selection screen where Enter should actually do something. If both conditions are true, it tries to get the currently selected item from the list using m.list.SelectedItem().(item). That type assertion might fail if something weird happened, we use the , ok idiom to safely check. If it successfully got the selected item, now the fun begins. We grab the filename (i.filename), try to read the file’s content using readAsset(), and handle any errors gracefully by storing a Error : %v message.\nEvery 80 milliseconds while the animation is running, it receives a tickMsg. This is the cue to advance the animation by one frame. It checks if m.viewing to make sure we’re still in viewing mode (the user might have pressed ‘q’ to go back to the list), and if so, it calls m.updateColumns() which moves each column’s offset forward, creating the scrolling effect.\nfunc (m *model) initColumns() { if m.width == 0 || len(m.content) == 0 { return } numCols := m.width / 2 if numCols \u003c 1 { numCols = 1 } m.columns = make([]column, numCols) runes := []rune(m.content) for i := range m.columns { m.columns[i] = column{ x: i * 2, height: rand.Intn(m.height) + 5, offset: rand.Intn(len(runes)), } } } func (m *model) updateColumns() { runes := []rune(m.content) if len(runes) == 0 { return } for i := range m.columns { m.columns[i].offset++ if m.columns[i].offset \u003e= len(runes) { m.columns[i].offset = 0 } if rand.Float32() \u003c 0.02 { m.columns[i].height = rand.Intn(m.height) + 5 } } } initColumns() sets up all the columns first – it’s like setting the stage before show begins. For sanity check, we use m.width == 0 || len(m.content) == 0. We then divide the terminal width by 2 (numCols := m.width / 2). Why 2? Because we want to space the columns out, creating gaps between cascading characters.\nNext, we allocate memory for all these columns using make([]column, numCols). We then convert the entire file content into runes []rune(m.content) to properly handle emojis, Chinese, Arabic characters or other Unicode content. rand.Intn(m.height) gives a random number between 0 and the terminal height, then we add 5 to ensure every column is at least 5 characters tall. The offset is also randomized rand.Intn(len(runes)). This determines where in the text file each column starts reading.\nThen we loop through every single column created and update it. For each column, we increment its offset by m.columns[i].offset++. Now, if the offset has reached or exceeded the length of the runes array, we wrap it back to zero (m.columns[i].offset = 0). This creates an infinite loop through the content. It’s like a circular buffer.\nEvery frame, for each column, we roll the dice with a 2% chance rand.Float32() \u003c 0.02. Think about it: rand.Float32() gives me a random number between 0.0 and 1.0.\nfunc (m model) View() string { if m.viewing { return m.matrixView() } if m.quitting { return quitTextStyle.Render(\"Quitting is for losers.\") } if m.list.Items() != nil { return \"\\n\" + m.list.View() } return \"\" } func (m model) matrixView() string { if len(m.columns) == 0 || len(m.content) == 0 { return \"\" } grid := make([][]rune, m.height) for i := range grid { grid[i] = make([]rune, m.width) for j := range grid[i] { grid[i][j] = ' ' } } runes := []rune(m.content) for _, col := range m.columns { if col.x \u003e= m.width { continue } for row := 0; row \u003c col.height \u0026\u0026 row \u003c m.height; row++ { charIdx := (col.offset + row) % len(runes) if charIdx \u003c 0 { charIdx += len(runes) } if row \u003c m.height \u0026\u0026 col.x \u003c m.width { grid[row][col.x] = runes[charIdx] } } } var result strings.Builder for rowIdx, row := range grid { for _, char := range row { if char != ' ' { color := getRandomColor() style := lipgloss.NewStyle().Foreground(lipgloss.Color(color)) result.WriteString(style.Render(string(char))) } else { result.WriteRune(' ') } } if rowIdx \u003c len(grid)-1 { result.WriteString(\"\\n\") } } return result.String() } Further, we proceed to displaying the rain on terminal screen. We achieve this by using View() with various conditions. If m.viewing is true, the matrixView() creates the rain effect, if not we let the user quit because we assume they are a loser xD. If the user is not viewing and not quitting, then they must be in list mode. We check if the list exists m.list.Items() != nil, and if so, return the list’s view with a newline prepended.\nNow, here’s the big idea: We create a 2D grid that represents every single character position on the screen. Think of it like graph paper where each cell can hold one character. We create this grid using make([][]rune, m.height) which gives a slice of slices - essentially a 2D array where the first dimension is rows (height) and the second is columns (width).\nWe iterate through all the columns. For each column, we first check if its x-position is off the screen (col.x \u003e= m.width). If someone resized the window smaller after the columns were created, some columns might be positioned beyond the right edge. We skip those with continue because trying to draw them would cause an out-of-bounds error.\nNext, we initialize this entire grid to spaces. Allocate space for m.width and fill all positions with ' '. This creates a blank canvas. Let’s break down (col.offset + row) % len(runes). On adding the offset and row we get a position in the source text. The % wraps the index around if it exceeds the text length. This creates that circular buffer effect where columns seamlessly loop through the content.\nWe then use a strings.Builder which is Go’s efficient way of building strings piece by piece. If the character is NOT a space, we generate a random color, create a Lipgloss style with that color, and render the character with that styling. Finally, result.String gives us the beautiful rain effect as a single string!\nExtensions So, while almost finishing the initial stages of matrix in go in the back of my mind I thought why not to increase the complexity xD. Here I go (pun intended): Image to ASCII Negatives Star Wars intro theme rendered into the terminal. ","wordCount":"2084","inLanguage":"en","datePublished":"2025-02-05T14:00:00Z","dateModified":"2025-02-05T14:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://isopath.github.io/posts/matrix-go/"},"publisher":{"@type":"Organization","name":"isopath","logo":{"@type":"ImageObject","url":"https://isopath.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://isopath.github.io/ accesskey=h title="isopath (Alt + H)">isopath</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://isopath.github.io/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">matrix.go</h1><div class=post-meta><span title='2025-02-05 14:00:00 +0000 UTC'>February 5, 2025</span></div></header><div class=post-content><p>Repository: <a href=https://github.com/isopath/matrix.go>https://github.com/isopath/matrix.go</a></p><hr><p><code>//go:embed</code> directive allows programs to include arbitrary files in the go binary at build time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//go:embed assets/*.txt</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>assetsFS</span> <span style=color:#a6e22e>embed</span>.<span style=color:#a6e22e>FS</span>
</span></span></code></pre></div><p>We use this to include all the text files from the <code>assets/</code> directory (used for the text for rain). All values are stored in the variable <code>assetsFS</code> of type <a href=https://pkg.go.dev/embed#FS><code>embed.FS</code></a>, a read-only collection of files (allowing for use with multiple go-routines). This is useful since we can use the <code>ReadFile</code> function to return the content of the files which we ship with the binary.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>listHeight</span> = <span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>titleStyle</span>        = <span style=color:#a6e22e>lipgloss</span>.<span style=color:#a6e22e>NewStyle</span>().<span style=color:#a6e22e>MarginLeft</span>(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>itemStyle</span>         = <span style=color:#a6e22e>lipgloss</span>.<span style=color:#a6e22e>NewStyle</span>().<span style=color:#a6e22e>PaddingLeft</span>(<span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>selectedItemStyle</span> = <span style=color:#a6e22e>lipgloss</span>.<span style=color:#a6e22e>NewStyle</span>().<span style=color:#a6e22e>PaddingLeft</span>(<span style=color:#ae81ff>2</span>).<span style=color:#a6e22e>Foreground</span>(<span style=color:#a6e22e>lipgloss</span>.<span style=color:#a6e22e>Color</span>(<span style=color:#e6db74>&#34;170&#34;</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>paginationStyle</span>   = <span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>DefaultStyles</span>().<span style=color:#a6e22e>PaginationStyle</span>.<span style=color:#a6e22e>PaddingLeft</span>(<span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>helpStyle</span>         = <span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>DefaultStyles</span>().<span style=color:#a6e22e>HelpStyle</span>.<span style=color:#a6e22e>PaddingLeft</span>(<span style=color:#ae81ff>4</span>).<span style=color:#a6e22e>PaddingBottom</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>quitTextStyle</span>     = <span style=color:#a6e22e>lipgloss</span>.<span style=color:#a6e22e>NewStyle</span>().<span style=color:#a6e22e>Margin</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>This is used downstream to change the &ldquo;style&rdquo; of the list component from bubbles. The way the API is structured one cannot pass custom styles at the point of creating the component, therefore we must create a new instance of &ldquo;style&rdquo; using <code>lipgloss.NewStyle()</code> and then pass it to the appropriate variable in <code>myList&lt;list>.Style</code>.</p><p><code>type item string</code></p><p>Here we define an item of type String.</p><p><code>func (i item) FilterValue() string { return "" }</code></p><p>The <code>FilterValue()</code> method is used to filter between each of the items. We need this because it is required by the <code>list.Item</code> interface. Even though we will later disable filtering (<code>l.SetFilteringEnabled(false)</code>), the interface still requires this method to be implemented. Without it, the code won&rsquo;t compile.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#a6e22e>itemDelegate</span>) <span style=color:#a6e22e>Height</span>() <span style=color:#66d9ef>int</span>                             { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#a6e22e>itemDelegate</span>) <span style=color:#a6e22e>Spacing</span>() <span style=color:#66d9ef>int</span>                            { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#a6e22e>itemDelegate</span>) <span style=color:#a6e22e>Update</span>(<span style=color:#a6e22e>_</span> <span style=color:#a6e22e>tea</span>.<span style=color:#a6e22e>Msg</span>, <span style=color:#a6e22e>_</span> <span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>Model</span>) <span style=color:#a6e22e>tea</span>.<span style=color:#a6e22e>Cmd</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> }
</span></span></code></pre></div><p>The <code>itemDelegate</code> struct implements the <code>list.ItemDelegate</code>. This interface allows us to customize how individual items are displayed and behave within a list component.</p><ul><li><code>Height()</code> defines the vertical height of each list item (1 in our case).</li><li><code>Spacing()</code> is used to add blank lines appear between list items. (0 to make it compact).</li><li><code>Update()</code> handles messages specific to individual items. Parameters supplied here are <code>tea.Msg</code> and <code>*list.Model</code> which we will learn about later.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#a6e22e>itemDelegate</span>) <span style=color:#a6e22e>Render</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Writer</span>, <span style=color:#a6e22e>m</span> <span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>Model</span>, <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>listItem</span> <span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>Item</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>listItem</span>.(<span style=color:#a6e22e>item</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>str</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%d. %s&#34;</span>, <span style=color:#a6e22e>index</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>i</span>.<span style=color:#a6e22e>title</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>itemStyle</span>.<span style=color:#a6e22e>Render</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>index</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Index</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fn</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>selectedItemStyle</span>.<span style=color:#a6e22e>Render</span>(<span style=color:#e6db74>&#34;&gt; &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>s</span>, <span style=color:#e6db74>&#34; &#34;</span>))
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>fn</span>(<span style=color:#a6e22e>str</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This contains various parameters of types such as <code>itemDelegate</code> has <code>d</code> which is the receiver to struct (covered earlier). We supply the output through <code>io.Writer</code> where <em>rendered</em> text will be written.</p><ul><li><code>list.Model</code> displays the parent list state (which item is selected).</li></ul><p><code>i, ok := listItem.(item)</code>
This is Go&rsquo;s type assertion feature. <code>list.Item</code> allows us to access fields like <code>.title</code> and <code>.filename</code>. If value of <code>i</code> is returned true, conversion has succeeded otherwise it means the type is wrong.</p><p><code>str := fmt.Sprintf("%d. %s", index+1, i.title)</code>
Here, we format the display string for providing us with options. <code>i.title</code> is used to display the form of text displayed (Matrix, Great Work, etc). We use <code>index+1</code> to add human friendly numbering beginning from 1.</p><p><code>fn := itemStyle.Render</code>
We use <code>.Render</code> for an item style that takes a string and returns a <em>styled</em> string.
<code>m.Index()</code> simply returns the currently selected item&rsquo;s index in the list. When selected, <code>fn</code> is triggered to add variadic parameter in <code>s ...string</code>.</p><p><code>selectedItemStyle.Render("> " + strings.Join(s, " "))</code>
<code>Render</code> applies the selected item style (purple color + 2 spaces padding).
Under <code>strings.Join()</code>, we simply prepend the arrow to the joined string to produce an output such as : <code>"> 1. Great Work"</code>.</p><p><code>fmt.Fprint(w, fn(str))</code>
Selects <code>fn</code> containing the formatted string and returns a styled version of it.
<code>w</code> writes the string to <code>io.Writer</code> for obtaining output.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#a6e22e>model</span>) <span style=color:#a6e22e>Init</span>() <span style=color:#a6e22e>tea</span>.<span style=color:#a6e22e>Cmd</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>viewing</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>tick</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>tick</span>() <span style=color:#a6e22e>tea</span>.<span style=color:#a6e22e>Cmd</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>tea</span>.<span style=color:#a6e22e>Tick</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span><span style=color:#f92672>*</span><span style=color:#ae81ff>80</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>) <span style=color:#a6e22e>tea</span>.<span style=color:#a6e22e>Msg</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>tickMsg</span>(<span style=color:#a6e22e>t</span>)
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>From a broad view, these two functions work together to implement animation timing in the Bubble Tea framework. They create a recurring &ldquo;heartbeat&rdquo; that drives the matrix rain effect.</p><p><code>return tick</code> performs on the boolean true result of <code>m.viewing</code>. tick starts the animation otherwise returns nil if boolean false.</p><p><code>tick() tea.Cmd</code> has a command output structure. It waits 80 milliseconds, sends a <code>tickMsg</code> back to the application and triggers next animation frame. 80ms is the sweet spot as it is smooth and consumes less CPU resources. <code>tickMsg</code> is a basic signal that says &ldquo;show next frame&rdquo;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#a6e22e>model</span>) <span style=color:#a6e22e>Update</span>(<span style=color:#a6e22e>msg</span> <span style=color:#a6e22e>tea</span>.<span style=color:#a6e22e>Msg</span>) (<span style=color:#a6e22e>tea</span>.<span style=color:#a6e22e>Model</span>, <span style=color:#a6e22e>tea</span>.<span style=color:#a6e22e>Cmd</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>msg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>msg</span>.(<span style=color:#66d9ef>type</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>tea</span>.<span style=color:#a6e22e>WindowSizeMsg</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>width</span> = <span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>Width</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>height</span> = <span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>Height</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>Items</span>() <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>SetWidth</span>(<span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>Width</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>viewing</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>initColumns</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>, <span style=color:#66d9ef>nil</span>
</span></span></code></pre></div><p>We implement the <code>Update</code> method here to process every single thing that happens (key press, window resize, timer tick, etc). To figure out the exact kind of message sent, we implement the <code>switch msg := msg.(type)</code>. In this particular case, we work with <code>tea.WindowSizeMsg</code> focusing on dragging to the corner to make it bigger or smaller via <code>msg.Width</code> and <code>msg Height</code> which adapts accordingly. Next we check whether it is in <code>m.viewing</code> mode, if it is, the Columns are recalculated based on new dimensions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#a6e22e>tea</span>.<span style=color:#a6e22e>KeyMsg</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>keypress</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>String</span>(); <span style=color:#a6e22e>keypress</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;q&#34;</span>, <span style=color:#e6db74>&#34;ctrl+c&#34;</span>:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>viewing</span> {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// If there&#39;s no list (direct mode), quit entirely</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>Items</span>() <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>quitting</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>tea</span>.<span style=color:#a6e22e>Quit</span>
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#75715e>// Otherwise return to list</span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>viewing</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>choice</span> = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>quitting</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>tea</span>.<span style=color:#a6e22e>Quit</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;enter&#34;</span>:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>viewing</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>Items</span>() <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>SelectedItem</span>().(<span style=color:#a6e22e>item</span>)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>choice</span> = <span style=color:#a6e22e>i</span>.<span style=color:#a6e22e>filename</span>
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>content</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>readAsset</span>(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>choice</span>)
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>						<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>content</span> = <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;Error: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>					} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>						<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>content</span> = <span style=color:#a6e22e>content</span>
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>viewing</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>initColumns</span>()
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>tick</span>()
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>tickMsg</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>viewing</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>updateColumns</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>tick</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>cmd</span> <span style=color:#a6e22e>tea</span>.<span style=color:#a6e22e>Cmd</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>Items</span>() <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>list</span>, <span style=color:#a6e22e>cmd</span> = <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>Update</span>(<span style=color:#a6e22e>msg</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>cmd</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here we have a set of cases defining various actions. <code>case "q", "ctrl+c":</code> simply quits the instance and clears the screen, but we check whether is being viewed or not first. If the <code>m.quitting</code> is true, <code>View()</code> shows the quit message <code>Quitting is for losers!</code> (which is indeed true).</p><p><code>case "enter":</code>
When you press Enter, it first checks whether it is being viewed and has a list, This makes sure we&rsquo;re in the file selection screen where Enter should actually do something. If both conditions are true, it tries to get the currently selected item from the list using <code>m.list.SelectedItem().(item)</code>. That type assertion might fail if something weird happened, we use the <code>, ok</code> idiom to safely check. If it successfully got the selected item, now the fun begins. We grab the filename (<code>i.filename</code>), try to read the file&rsquo;s content using <code>readAsset()</code>, and handle any errors gracefully by storing a <code>Error : %v</code> message.</p><p>Every 80 milliseconds while the animation is running, it receives a <code>tickMsg</code>. This is the cue to advance the animation by one frame. It checks <code>if m.viewing</code> to make sure we&rsquo;re still in viewing mode (the user might have pressed &lsquo;q&rsquo; to go back to the list), and if so, it calls <code>m.updateColumns()</code> which moves each column&rsquo;s offset forward, creating the scrolling effect.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>model</span>) <span style=color:#a6e22e>initColumns</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>width</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> len(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>content</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>numCols</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>width</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>numCols</span> &lt; <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>numCols</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>columns</span> = make([]<span style=color:#a6e22e>column</span>, <span style=color:#a6e22e>numCols</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runes</span> <span style=color:#f92672>:=</span> []rune(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>content</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>columns</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>columns</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>column</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>x</span>:      <span style=color:#a6e22e>i</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>height</span>: <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>height</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>offset</span>: <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(len(<span style=color:#a6e22e>runes</span>)),
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>model</span>) <span style=color:#a6e22e>updateColumns</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runes</span> <span style=color:#f92672>:=</span> []rune(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>content</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>runes</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>columns</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>columns</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>offset</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>columns</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>offset</span> <span style=color:#f92672>&gt;=</span> len(<span style=color:#a6e22e>runes</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>columns</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>offset</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Float32</span>() &lt; <span style=color:#ae81ff>0.02</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>columns</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>height</span> = <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>height</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>initColumns()</code> sets up all the columns first &ndash; it&rsquo;s like setting the stage before show begins. For sanity check, we use <code>m.width == 0 || len(m.content) == 0</code>. We then divide the terminal width by 2 (<code>numCols := m.width / 2</code>). Why 2? Because we want to space the columns out, creating gaps between cascading characters.</p><p>Next, we allocate memory for all these columns using <code>make([]column, numCols)</code>. We then convert the entire file content into runes <code>[]rune(m.content)</code> to properly handle emojis, Chinese, Arabic characters or other Unicode content.
<code>rand.Intn(m.height)</code> gives a random number between 0 and the terminal height, then we add 5 to ensure every column is at least 5 characters tall. The <em>offset</em> is also randomized <code>rand.Intn(len(runes))</code>. This determines where in the text file each column starts reading.</p><p>Then we loop through every single column created and update it. For each column, we increment its offset by <code>m.columns[i].offset++</code>. Now, if the offset has reached or exceeded the length of the runes array, we wrap it back to zero (<code>m.columns[i].offset = 0</code>). This creates an infinite loop through the content. It&rsquo;s like a circular buffer.</p><p>Every frame, for each column, we roll the dice with a 2% chance <code>rand.Float32() &lt; 0.02</code>. Think about it: <code>rand.Float32()</code> gives me a random number between 0.0 and 1.0.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#a6e22e>model</span>) <span style=color:#a6e22e>View</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>viewing</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>matrixView</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>quitting</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>quitTextStyle</span>.<span style=color:#a6e22e>Render</span>(<span style=color:#e6db74>&#34;Quitting is for losers.&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>Items</span>() <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;\n&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>View</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#a6e22e>model</span>) <span style=color:#a6e22e>matrixView</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>columns</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> len(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>content</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>grid</span> <span style=color:#f92672>:=</span> make([][]<span style=color:#66d9ef>rune</span>, <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>height</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>grid</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>i</span>] = make([]<span style=color:#66d9ef>rune</span>, <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>width</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>i</span>] {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>i</span>][<span style=color:#a6e22e>j</span>] = <span style=color:#e6db74>&#39; &#39;</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runes</span> <span style=color:#f92672>:=</span> []rune(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>content</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>col</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>columns</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>col</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>width</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>row</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>row</span> &lt; <span style=color:#a6e22e>col</span>.<span style=color:#a6e22e>height</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>row</span> &lt; <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>height</span>; <span style=color:#a6e22e>row</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>charIdx</span> <span style=color:#f92672>:=</span> (<span style=color:#a6e22e>col</span>.<span style=color:#a6e22e>offset</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>row</span>) <span style=color:#f92672>%</span> len(<span style=color:#a6e22e>runes</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>charIdx</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>charIdx</span> <span style=color:#f92672>+=</span> len(<span style=color:#a6e22e>runes</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>row</span> &lt; <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>height</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>col</span>.<span style=color:#a6e22e>x</span> &lt; <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>width</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>row</span>][<span style=color:#a6e22e>col</span>.<span style=color:#a6e22e>x</span>] = <span style=color:#a6e22e>runes</span>[<span style=color:#a6e22e>charIdx</span>]
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>result</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Builder</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>rowIdx</span>, <span style=color:#a6e22e>row</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>grid</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>char</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>row</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>char</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39; &#39;</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>color</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getRandomColor</span>()
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>style</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lipgloss</span>.<span style=color:#a6e22e>NewStyle</span>().<span style=color:#a6e22e>Foreground</span>(<span style=color:#a6e22e>lipgloss</span>.<span style=color:#a6e22e>Color</span>(<span style=color:#a6e22e>color</span>))
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#a6e22e>style</span>.<span style=color:#a6e22e>Render</span>(string(<span style=color:#a6e22e>char</span>)))
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>WriteRune</span>(<span style=color:#e6db74>&#39; &#39;</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>rowIdx</span> &lt; len(<span style=color:#a6e22e>grid</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#e6db74>&#34;\n&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>String</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Further, we proceed to displaying the rain on terminal screen. We achieve this by using <code>View()</code> with various conditions. If <code>m.viewing</code> is true, the <code>matrixView()</code> creates the rain effect, if not we let the user quit because we assume they are a loser xD. If the user is not viewing and not quitting, then they must be in list mode. We check if the list exists <code>m.list.Items() != nil</code>, and if so, return the list&rsquo;s view with a newline prepended.</p><p>Now, here&rsquo;s the big idea: We create a 2D grid that represents every single character position on the screen. Think of it like graph paper where each cell can hold one character. We create this grid using <code>make([][]rune, m.height)</code> which gives a slice of slices - essentially a 2D array where the first dimension is rows (height) and the second is columns (width).</p><p>We iterate through all the columns. For each column, we first check if its x-position is off the screen (<code>col.x >= m.width</code>). If someone resized the window smaller after the columns were created, some columns might be positioned beyond the right edge. We skip those with <code>continue</code> because trying to draw them would cause an out-of-bounds error.</p><p>Next, we initialize this entire grid to spaces. Allocate space for <code>m.width</code> and fill all positions with <code>' '</code>. This creates a blank canvas. Let&rsquo;s break down <code>(col.offset + row) % len(runes)</code>. On adding the offset and row we get a position in the source text. The <code>%</code> wraps the index around if it exceeds the text length. This creates that circular buffer effect where columns seamlessly loop through the content.</p><p>We then use a <code>strings.Builder</code> which is Go&rsquo;s efficient way of building strings piece by piece. If the character is NOT a space, we generate a random color, create a <a href=https://pkg.go.dev/github.com/charmbracelet/lipgloss#section-readme>Lipgloss</a> style with that color, and render the character with that styling. Finally, <code>result.String</code> gives us the beautiful rain effect as a single string!</p><hr><h3 id=extensions>Extensions<a hidden class=anchor aria-hidden=true href=#extensions>#</a></h3><ol><li>So, while almost finishing the initial stages of matrix in go in the back of my mind I thought why not to increase the complexity xD. Here I go (pun intended):<ul><li><a href=https://arena.ai/c/019c14eb-c963-7bcb-999f-919e56ed8d53>Image to ASCII Negatives</a></li></ul></li><li>Star Wars intro theme rendered into the terminal.</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://isopath.github.io/tags/go/>Go</a></li><li><a href=https://isopath.github.io/tags/bubbletea/>Bubbletea</a></li><li><a href=https://isopath.github.io/tags/terminal/>Terminal</a></li><li><a href=https://isopath.github.io/tags/tui/>Tui</a></li></ul><nav class=paginav><a class=prev href=https://isopath.github.io/posts/lsp-pl/><span class=title>« Prev</span><br><span>lsp.pl</span>
</a><a class=next href=https://isopath.github.io/posts/vm-rs/><span class=title>Next »</span><br><span>vm.rs</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://isopath.github.io/>isopath</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>